# Redux Thunks with createAsyncThunk

## Overview

This guide explains how to handle asynchronous operations in Redux using `createAsyncThunk`. We'll implement geolocation fetching and reverse geocoding to get the user's address automatically.

---

## 1. Helper Function - Getting User Position

### Code Implementation

```js
function getPosition() {
  return new Promise(function (resolve, reject) {
    // Wraps browser's geolocation API in a Promise for async/await usage
    navigator.geolocation.getCurrentPosition(resolve, reject);
  });
}
```

### How It Works

- **Promisifies** the browser's geolocation API
- **Returns**: A Promise that resolves with position data or rejects on error
- **Why Needed**: Browser's `getCurrentPosition` uses callbacks; wrapping it allows async/await

---

## 2. Creating the Async Thunk

### Code Implementation

```js
export const fetchAddress = createAsyncThunk(
  "user/fetchAddress", // Action type prefix
  async function () {
    // 1) Get the user's geolocation position
    const positionObj = await getPosition();
    const position = {
      latitude: positionObj.coords.latitude,
      longitude: positionObj.coords.longitude,
    };

    // 2) Use reverse geocoding API to convert coordinates to readable address
    // This allows users to see and correct their address in the order form
    const addressObj = await getAddress(position);
    const address = `${addressObj?.locality}, ${addressObj?.city} ${addressObj?.postcode}, ${addressObj?.countryName}`;

    // 3) Return data as the thunk's payload
    // This will be available in action.payload when fulfilled
    return { position, address };
  },
);
```

### How It Works

1. **Action Type**: `"user/fetchAddress"` generates three action types automatically:
   - `user/fetchAddress/pending`
   - `user/fetchAddress/fulfilled`
   - `user/fetchAddress/rejected`

2. **Async Logic**:
   - Gets user's GPS coordinates
   - Converts coordinates to human-readable address
   - Returns both position and address

3. **Payload**: The returned object becomes `action.payload` in the fulfilled case

---

## 3. Setting Up the Redux Slice

### Initial State

```js
const initialState = {
  username: "",
  status: "idle", // Tracks async operation state: 'idle' | 'loading' | 'error'
  position: {}, // Stores latitude/longitude
  address: "", // Stores formatted address string
  error: "", // Stores error message if fetch fails
};
```

### Slice with extraReducers

```js
const userSlice = createSlice({
  name: "user",
  initialState,
  reducers: {
    // Regular synchronous reducer
    updateName(state, action) {
      state.username = action.payload; // Redux Toolkit allows direct mutation
    },
  },
  // Handle async thunk actions
  extraReducers: (builder) =>
    builder
      // When fetchAddress starts
      .addCase(fetchAddress.pending, (state) => {
        state.status = "loading"; // Show loading indicator
      })
      // When fetchAddress succeeds
      .addCase(fetchAddress.fulfilled, (state, action) => {
        state.position = action.payload.position; // Store coordinates
        state.address = action.payload.address; // Store formatted address
        state.status = "idle"; // Reset status
      })
      // When fetchAddress fails
      .addCase(fetchAddress.rejected, (state, action) => {
        state.status = "error"; // Mark as error
        state.error = action.error.message; // Store error message
      }),
});
```

### How It Works

**Regular Reducers**:

- Handle synchronous actions like updating username

**extraReducers**:

- Handle actions generated by `createAsyncThunk`
- Use builder pattern to add cases for pending/fulfilled/rejected states

**State Updates**:

- **Pending**: Set status to "loading"
- **Fulfilled**: Store fetched data, reset to "idle"
- **Rejected**: Set error status and message

---

## 4. Using in Components

### Code Implementation

```jsx
import { useDispatch } from "react-redux";
import { fetchAddress } from "./userSlice";

function CreateOrder() {
  const dispatch = useDispatch();

  return <button onClick={() => dispatch(fetchAddress())}>Get position</button>;
}
```

### How It Works

1. **Click Event**: User clicks "Get position" button
2. **Dispatch Thunk**: `dispatch(fetchAddress())` starts the async operation
3. **Automatic Actions**: Redux automatically dispatches pending/fulfilled/rejected actions
4. **State Updates**: Component re-renders as state changes

---

## Complete Data Flow

```
User clicks "Get position"
    â†“
dispatch(fetchAddress()) called
    â†“
fetchAddress.pending dispatched â†’ status = "loading"
    â†“
getPosition() fetches GPS coordinates
    â†“
getAddress() converts coordinates to address
    â†“
SUCCESS PATH:
  fetchAddress.fulfilled dispatched
    â†’ position & address stored
    â†’ status = "idle"
    â†“
  Component shows address in form

ERROR PATH:
  fetchAddress.rejected dispatched
    â†’ error message stored
    â†’ status = "error"
    â†“
  Component shows error message
```

---

## Key Benefits

âœ… **Automatic Action Types**: createAsyncThunk generates pending/fulfilled/rejected actions

âœ… **Clean Async Logic**: Async code stays in thunk, reducers remain pure

âœ… **Built-in Status Tracking**: Easy to show loading states and errors

âœ… **Type Safety**: TypeScript support out of the box

âœ… **Error Handling**: Rejected state automatically catches errors

---

## Important Notes

ðŸ’¡ **Status States**:

- `idle`: No operation in progress
- `loading`: Fetching data
- `error`: Operation failed

ðŸ’¡ **Browser Permissions**: User must grant location access for this to work

âš ï¸ **Error Handling**: Always handle the rejected case to show meaningful error messages

ðŸ’¡ **Payload Access**: In fulfilled case, use `action.payload.position` and `action.payload.address`

---

## Using Status in Components

```jsx
function CreateOrder() {
  const { status, address, error } = useSelector((state) => state.user);
  const dispatch = useDispatch();

  return (
    <div>
      <button
        onClick={() => dispatch(fetchAddress())}
        disabled={status === "loading"}
      >
        {status === "loading" ? "Getting position..." : "Get position"}
      </button>

      {status === "error" && <p className="error">{error}</p>}
      {address && <p>Your address: {address}</p>}
    </div>
  );
}
```

---

## Next Steps

Continue to: [Integrating geolocation](./39-integrating-geolocation.md)
